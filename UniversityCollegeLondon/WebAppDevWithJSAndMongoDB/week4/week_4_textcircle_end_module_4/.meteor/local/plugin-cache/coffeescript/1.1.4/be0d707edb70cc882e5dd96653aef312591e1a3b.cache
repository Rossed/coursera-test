{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Fiber, Future, LogicalOps, _monkeyPatch, _submitOpMonkeyPatched, runValidations,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nFiber = Npm.require('fibers');\n\nFuture = Npm.require('fibers/future');\n\nLogicalOps = {\n  'or': function(a, b) {\n    return a || b;\n  },\n  'and': function(a, b) {\n    return a && b;\n  }\n};\n\nrunValidations = function(currentOp, validations, doc, token) {\n  var k, lookIn, nestedResult, result, v;\n  if (currentOp === null) {\n    if ((validations != null ? validations.or : void 0) != null) {\n      return runValidations(\"or\", validations.or, doc, token);\n    } else if ((validations != null ? validations.and : void 0) != null) {\n      return runValidations(\"and\", validations.and, doc, token);\n    } else if (validations != null) {\n      return runValidations(\"and\", validations, doc, token);\n    } else {\n      return true;\n    }\n  } else if (currentOp != null) {\n    if (currentOp === \"or\") {\n      result = false;\n    } else if (currentOp = \"and\") {\n      result = true;\n    }\n    for (k in validations) {\n      v = validations[k];\n      if (k === \"or\" || k === \"and\") {\n        nestedResult = runValidations(k, v, doc, token);\n        result = LogicalOps[currentOp](result, nestedResult);\n      } else {\n        switch (v) {\n          case \"is_in_array\":\n            result = LogicalOps[currentOp](result, indexOf.call(doc[k], token) >= 0);\n            break;\n          case \"isnt_in_array\":\n            lookIn = doc.k || [];\n            result = LogicalOps[currentOp](result, indexOf.call(doc[k], token) < 0);\n            break;\n          case \"is_equal\":\n            result = LogicalOps[currentOp](result, token === doc[k]);\n            break;\n          case \"isnt_equal\":\n            result = LogicalOps[currentOp](result, token === !doc[k]);\n        }\n      }\n    }\n    return result;\n  }\n};\n\n_submitOpMonkeyPatched = false;\n\n_monkeyPatch = function(agent) {\n  var UserAgent, model;\n  UserAgent = Object.getPrototypeOf(agent);\n  model = ShareJS.model;\n  UserAgent.submitOp = function(docName, opData, callback) {\n    var dupIfSource;\n    opData.meta || (opData.meta = {});\n    opData.meta.userId = this.name;\n    opData.meta.source = this.sessionId;\n    dupIfSource = opData.dupIfSource || [];\n    if (opData.op) {\n      return this.doAuth({\n        docName: docName,\n        op: opData.op,\n        v: opData.v,\n        meta: opData.meta,\n        dupIfSource: dupIfSource\n      }, 'submit op', callback, (function(_this) {\n        return function() {\n          return model.applyOp(docName, opData, callback);\n        };\n      })(this));\n    } else {\n      return this.doAuth({\n        docName: docName,\n        meta: opData.meta\n      }, 'submit meta', callback, (function(_this) {\n        return function() {\n          return model.applyMetaOp(docName, opData, callback);\n        };\n      })(this));\n    }\n  };\n  console.log(\"ShareJS: patched UserAgent submitOp function to record Meteor userId\");\n  return _submitOpMonkeyPatched = true;\n};\n\nthis.MeteorAccountsAuthHandler = (function() {\n  function MeteorAccountsAuthHandler(options, client) {\n    this.options = options;\n    this.client = client;\n    this.handle = bind(this.handle, this);\n  }\n\n  MeteorAccountsAuthHandler.prototype.fetchDocument = function(collection, key) {\n    var future;\n    future = new Future;\n    this.client.collection(collection, function(err, collection) {\n      if (err) {\n        return future[\"throw\"](err);\n      }\n      return collection.findOne({\n        _id: key\n      }, function(err, doc) {\n        if (err) {\n          console.warn(\"failed to get doc in \" + collection + \" with key \" + key + \": \" + err);\n        }\n        if (err) {\n          future[\"throw\"](null);\n        }\n        return future[\"return\"](doc);\n      });\n    });\n    return future;\n  };\n\n  MeteorAccountsAuthHandler.prototype.getAuthentication = function(agent) {\n    var collection, future, token, user, validations;\n    token = agent.authentication;\n    validations = this.options.authenticate.token_validations;\n    collection = this.options.authenticate.collection;\n    future = new Future;\n    user = this.fetchDocument(collection, agent.authentication).wait();\n    if (!((user != null) || ((validations.or != null) && (validations.and != null)))) {\n      future[\"return\"](false);\n    }\n    future[\"return\"](runValidations(null, validations, user, token));\n    return future;\n  };\n\n  MeteorAccountsAuthHandler.prototype.getAuthorization = function(agent, action) {\n    var collection, doc, future, token, validations;\n    token = agent.authentication;\n    validations = this.options.authorize.token_validations;\n    collection = this.options.authorize.collection;\n    future = new Future;\n    doc = this.fetchDocument(collection, action.docName).wait();\n    if (!((doc != null) || ((validations.or != null) && (validations.and != null)))) {\n      future[\"return\"](false);\n    }\n    future[\"return\"](runValidations(null, validations, doc, token));\n    return future;\n  };\n\n  MeteorAccountsAuthHandler.prototype.handle = function(agent, action) {\n    var authenticate, authorize, opsToAuthorize, ref;\n    if (!_submitOpMonkeyPatched) {\n      _monkeyPatch(agent);\n    }\n    authenticate = this.options.authenticate != null;\n    authorize = this.options.authorize != null;\n    opsToAuthorize = (ref = this.options.authorize) != null ? ref.apply_on : void 0;\n    return (Fiber(((function(_this) {\n      return function() {\n        var ref1, res;\n        res = false;\n        if (authenticate && (action.type === \"connect\")) {\n          res = _this.getAuthentication(agent).wait();\n          if (res) {\n            agent.name = agent.authentication;\n          }\n        } else if (authorize && (ref1 = action.type, indexOf.call(opsToAuthorize, ref1) >= 0)) {\n          res = _this.getAuthorization(agent, action).wait();\n        } else {\n          res = true;\n        }\n        if (res) {\n          return action.accept();\n        } else {\n          return action.reject();\n        }\n      };\n    })(this)))).run();\n  };\n\n  return MeteorAccountsAuthHandler;\n\n})();\n","sourceMap":{"version":3,"file":"/sharejs-meteor-auth.coffee.js","sourceRoot":"","sources":["/packages/mizzao_sharejs/sharejs-meteor-auth.coffee"],"names":[],"mappings":"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","sourcesContent":["# Auth API helpers\nFiber = Npm.require('fibers');\nFuture = Npm.require('fibers/future')\n\n# Metaprogramming aids\nLogicalOps =\n    'or'  : (a, b) -> a or b\n    'and' : (a, b) -> a and b\n\n# Recursively evaluate the validations provided in settings.json\nrunValidations = (currentOp, validations, doc, token) ->\n  if currentOp is null\n    if validations?.or?\n      # recurse into or\n      return runValidations(\"or\", validations.or, doc, token)\n    else if validations?.and?\n      # recurse into and\n      return runValidations(\"and\", validations.and, doc, token)\n    else if validations?\n      # If no higher level \"or\" and \"and\", default to \"and\"\n      return runValidations(\"and\", validations, doc, token)\n    else\n      # No validations being asked to run - user possibly just wants to check\n      # for presence of user/doc\n      return true\n  else if currentOp?\n    if currentOp is \"or\"\n      result = false\n    else if currentOp = \"and\"\n      result = true\n\n    for k, v of validations\n      if k in [\"or\", \"and\"]\n        # recurse into or/and\n        nestedResult = runValidations(k, v, doc, token)\n        result = LogicalOps[currentOp](result, nestedResult)\n      else\n        switch v\n          when \"is_in_array\"\n            result = LogicalOps[currentOp](result, token in doc[k])\n          when \"isnt_in_array\"\n            lookIn = doc.k or []\n            result = LogicalOps[currentOp](result, token not in doc[k])\n          when \"is_equal\"\n            result = LogicalOps[currentOp](result, token is doc[k])\n          when \"isnt_equal\"\n            result = LogicalOps[currentOp](result, token is not doc[k])\n    return result\n\n_submitOpMonkeyPatched = false\n\n_monkeyPatch = (agent) ->\n  UserAgent = Object.getPrototypeOf(agent)\n  model = ShareJS.model\n  # Overriding https://github.com/share/ShareJS/blob/v0.6.2/src/server/useragent.coffee,\n  # including variables in closure. >.< @josephg\n  UserAgent.submitOp = (docName, opData, callback) ->\n    opData.meta ||= {}\n    opData.meta.userId = @name\n    opData.meta.source = @sessionId\n    dupIfSource = opData.dupIfSource or []\n\n    # If ops and meta get coalesced, they should be separated here.\n    if opData.op\n      @doAuth {docName, op:opData.op, v:opData.v, meta:opData.meta, dupIfSource}, 'submit op', callback, =>\n        model.applyOp docName, opData, callback\n    else\n      @doAuth {docName, meta:opData.meta}, 'submit meta', callback, =>\n        model.applyMetaOp docName, opData, callback\n\n  console.log \"ShareJS: patched UserAgent submitOp function to record Meteor userId\"\n  _submitOpMonkeyPatched = true\n\n# Based on https://github.com/share/ShareJS/wiki/User-access-control\nclass @MeteorAccountsAuthHandler\n  constructor: (@options, @client) ->\n\n  # Get a future that resolves to the entry from the database for given query\n  fetchDocument: (collection, key) ->\n    future = new Future\n    @client.collection collection, (err, collection) ->\n      return future.throw(err) if err\n\n      collection.findOne {_id: key}, (err, doc) ->\n        console.warn \"failed to get doc in #{collection} with key #{key}: #{err}\" if err\n        future.throw(null) if err\n        future.return(doc)\n\n    return future\n\n  # Get a future that would resolve to authentication as a bool\n  getAuthentication: (agent) ->\n    token = agent.authentication\n    validations = @options.authenticate.token_validations\n    collection = @options.authenticate.collection\n\n    future = new Future\n\n    user = @fetchDocument(collection, agent.authentication).wait()\n    # Not having user necessitates bailing out!\n    # Having both \"and\" and \"or\" on the top level is not allowed\n    unless user? or (validations.or? and validations.and?)\n      future.return false\n\n    future.return runValidations(null, validations, user, token)\n\n    return future\n\n  # Get a future that would resolve to authorization as a bool\n  getAuthorization: (agent, action) ->\n    token = agent.authentication\n    validations = @options.authorize.token_validations\n    collection = @options.authorize.collection\n\n    future = new Future\n\n    doc = @fetchDocument(collection, action.docName).wait()\n    # Not having document necessitates bailing out!\n    # Having both \"and\" and \"or\" on the top level is not allowed\n    unless doc? or (validations.or? and validations.and?)\n      future.return false\n\n    future.return runValidations(null, validations, doc, token)\n\n    return future\n\n  handle: (agent, action) =>\n    # This is ugly, but we have no other way to store Meteor usernames in ShareJS 0.6.2\n    _monkeyPatch(agent) unless _submitOpMonkeyPatched\n\n    authenticate = @options.authenticate?\n    authorize = @options.authorize?\n    opsToAuthorize = @options.authorize?.apply_on\n\n    (Fiber (=>\n      res = false\n\n      if authenticate and (action.type is \"connect\")\n        res = @getAuthentication(agent).wait()\n        # Save Meteor userId if we successfully authenticated\n        agent.name = agent.authentication if res\n\n      else if authorize and action.type in opsToAuthorize\n        res = @getAuthorization(agent, action).wait()\n      else\n        # Accept all other actions\n        res = true\n\n      if res\n        action.accept()\n      else\n        action.reject()\n    )).run()\n"]}}